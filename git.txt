Изучение гит. 
----------------------------------------------------------------------------------------------------------------
1. Общие сведения.

----------------------------------------------------------------------------------------------------------------
2. Установка и настройка Гит
Скачиваем с офсайта git-scm.com (source code manager)
Для Linux необходима дополнительная доустановка скрипта для включения автозаполнения

Настройки бывают 3-х уровней:
 - System. Вцелом для всего компа (кто бы не использовал Гит). Лежат в /etc/gitconfig (Линукс) или /program files/git/etc/gitconfig (Винда)
	Комманда для быстрого редактирования: git config --system
 - User. Настройки для текущего пользователя системы. Лежат в ~/.gitconfig или $HOME/.gitconfig
	git config --global
 - Project. Особые настройки для конкретного пректа. Лежат в my_project/.git/config
	git config [ничего нету - значит для проекта]
	
Базовые настройки:
git config --global user.name "Alex" (Установить имя на уровне пользователя компьютера (уровень user))
git config --global user.email "rpk7@yandex.ru" (Установить мыло автора)
git config --global core.editor "notepad" (устанавливает редактор для тех случаев, когда открывается редактор)
git config --global color.ui true (установить окрашивание в цвета для вывода)
git config --list (отобразить установленные настройки)
git config user.name (выдаст значение этой записи)

----------------------------------------------------------------------------------------------------------------
3. Начинаем
Инициализация репозитория Гит
git init (Выполнить в каталоге, где нужно начать отслеживать; иными словами, эта папка будет репозиторием)
Тут же создалась папка .git, она всегда на самом верхнем уровне созданного репозитория. Ее лучше не трогать. И там лежит вся вся инфа по проекту.

git add file_name (Добавить файл для отслеживания)
git add . (Точка. Добавить все файлы для отслеживания)
git commit -m "Message" (Сделать коммит (слепок) и обозначить его сообщением Message)
git commit -am "Message" (Добавить все файлы в отслеживание и сделать коммит (слепок) и обозначить его сообщением Message)

git log (Список коммитов)
git log -n N (покажет только N записей)
git log --since=2015-05-26 (Показать все коммиты начиная с даты)
git log --until=2-15-05-26 (показать все коммиты кторые были до числа)
git log --author="name of author" (показывает все коммиты определенного автора)
git log --grep="reg_expr" (Ищет коммиты по регулярному выражению в описании)

----------------------------------------------------------------------------------------------------------------
4. Концепция и архетиктура Гит
Архитектура трех деревьев.
При выполнении комманды git add файлы попадают из рабочей дтиректории в буфер, а при выполнении git commit файлы попадают из буфера в репозиторий.
Таким образом достигается гибкость, что позволяет сохранять то что нужно, например, мы сделали много изменений, но для текущего коммита нам не нужны
все файлы. Так, имею промежуточное звено (буфер), мы можем добиваться необходимых результатов.

Структура:
Repository
  |
Staging index (Buffer)
  |
Working directory

В каждом коммите имеется свой хэш SHA-1 (40 символов) со всего слепка (не с файла). И каждый следующий ссылается на предыдущий. Так возможна 
целостность и гит может собирать корректные версии файлов на основании всех предыдущих изменений. Так, это делает невозможным поменять файлы из 
промежуточного коммита, так как это собьет хэши последующий коммитов. 

Существует указатель HEAD, который всегда указывает на верхушку текущего репозитория (последний коммит). Указывает на родителя следующего коммита.
мы можем перемещаться по дереву коммитов, меняя HEAD. 

----------------------------------------------------------------------------------------------------------------
5. Внесение изменений в файлы

Добавление файлов (новых и измененных)
git status (показывает новые, измененные, удаленные, переименованные файлы и папки)
git add file_name (Добавить файл для отслеживания, тоесть, помещение его в буффер, а именно оттуда и идут в коммит)
git reset HEAD file_name (убрать файл из буффера, тоесть вернуть к первоначальному состоянию коммита)

Сравнение файлов
git diff (сверяет файлы из репозитория и рабочей директорией)
git diff file_name (сверяет указанный файл из репозитория и рабочей директорией)
git diff --staged (сравнивает файлы между репозиторием и буфером)

Удаление файлов
Для начала эти файлы должны быть закомичены, иначе нету смысла их удалять\не удалять
Два пути: 
 - Удалить файл из рабочей директории.  (так, при git status он будет помечен как удаленный)
   Потом выполнить git rm file_name (удаляет файл из отслеживаемых).
 - Сразу воспользоваться коммандой
   git rm file_name (удалит файл с рабочей директории и добавит его в буффер на удаление). Так лучше, быстрее и проще. Гит сам за нас все делает.
   
Переименовывание файлов
Тут тоже два способа:
 - Переименовываем файл из рабочей директории. Он новое имя определяет как новый, а старый - как удаленный.
   Новый нужно добавить при помощи git add file_name
   Старый нужно удалить при помощи git rm file_name
   Если посмотреть git status, то при совпадении их содержания (до 50%) он может догадаться что это наш старый файл. И помечает его как переименованный.
 - Второй способ. Тут мы сразу пишем 
   git mv first_name new_name (Переименовывает файлы сам в рабочей директории и добавляет изменения в буффер). Таким образом, мы избавились от ненужных шагов, и этот способ является самым лучшим и быстрым. Гит всё сам делает за нас.

Перемещение файлов
Тоже самое, что и переименовывание. Это синонимы.
git mv git.txt new_dir/test.txt
Гит пометит его как переименованный.

----------------------------------------------------------------------------------------------------------------
6. Использование Гит с реальным проектом

По сути инфа с предыдущих глав. Просто это все показывается на примерах, и детально разжовывается.

----------------------------------------------------------------------------------------------------------------
7. Отмена изменений

Восстановление файлов рабочей директории из репозитория
git checkout file_name (Восстанавливает указанный файл или ветку (ветка в приоритете) с репозитория)
git checkout -- file_name (Восстанавливает указанный файл, два дефиса указываютявно на то, чтоюы оставатьсяв текущей ветке и восстанавливать файл)
git checkout SHA_first_digits -- filename (Восстановить файл с слепка SHA текущей ветки. При кождом чекауте файл добавляется в буфер тут же)

Удаление файлов с буфера
git reset HEAD filename (Удалить из буфера файл. HEAD указывает, что по сути, восстановить состояние буфера как в репозитории на момент HEAD)

Изменение коммитов (последнего) (отменить произвольный невозможно, так как все строится на хэше от предыдущего)
git commit --amend -m "message" (изменить/перезаписать последний коммит)

Зеркальное отображение коммита, тоесть, что было удалено - добавляется, что добавлено - удалено, что измененно - восстанавливается.
При этом создадится новый коммит. По сути, это отмена указанного коммита и автоматическое создание коммита. По идее, это возвращение к состоянию файлов предыдущего коммита, но с созданием нового коммита.
git revert SHA (происходит зеркальное обращение указанного коммита. Появится редактор для редакатирования сообщения и после его закрытия - автокоммит)

Перемотка на любой коммит. Будет подробно идти речь об git reset. До этого о ней было известно как о средстве удаления отслеживаемых файлов из буффера. Но это мощнй инструмент для восстановления файлов.
Есть 3 основные опции :
-- soft (перемещает указатель HEAD на указанный коммит и только. При этом не затрагиваются ни буффер, ни рабочая директория. Самая безопасная. Удобно для дальнейшего выполнения git diff. Если выполнить git status, то будет как измененные файлы ,которые следует закомитить. Это потому, что рабочая директория == буферу, но они не равляются состоянию репозитория)
	git reset --soft SHA
-- mixed (default. Премещает указатель на указанный коммит, не меняет рабочую директорию, но меняет буфер, тоесть, устанавливает его как в указанном коммите. Вот почему по умолчанию эта комманда удаляет файл из буффера, ведь он будет такой же ,как и в коммите)
	git reset --mixed SHA
-- hard (перемещает указатель на указанный комиит, меняет в соответствие ему как буффер, так и рабочую директорию. Самый опасный. При этом удалятся все последуюющие коммиты. Но не сразу, можно будет еще вернуться к последнему коммиту, зная ее SHA)
	git reset --hard SHA
Во всех трёх случаях настоящий последний коммит (а не то куда сейчас стала указывать HEAD) можно вернуть, зная его SHA. Это можно сделать до тех пор, пока не создано новый коммит от перемещенного указателя.

Удаление неотслеживаемых файлов. Когда в проекте имеются побочные файлы (файлы компиляции, временные и т.д.) возникает необходимость их удалить. Ибо нам они только мешают и их отслеживать не требуется. Для удаления неотслеживаемых файлов есть комманда:
git clean (выдаст ошибку, так как обязательно требует параметров)
git clean -n (тестовое удаление, тоесть, выдаст список файлов, которые подлеэат удалению при нетестовой чистке)
git clean -f (Удаляет все неотслеживаемые файлы. Оккуратно!)

----------------------------------------------------------------------------------------------------------------
8. Игнорирование файлов
Для создания правил, какие файлы нужно игнорировать и не отслеживать, для этого можно:
 - создать файл в директории проекта (project_dir/.gitignore) - игнор на уровне проекта
 - Глобальное игнорирование - для этого нужно выполнить ряд действий:
	git config --global core.excludesfiles ~/.gitignore_global (прописать в настройках расположение файла глобального и гнора)
	ну и собственно создать указанный файл и прописать в нем правила игнора
 
В правилах игнора можно указывать по следующих правилах:
 - самые базовые возможности регулярных выражений: * ? [aesad] [0-9]
 - Отрицание с использованием "!"
	Например, такие строки в .gitignore
	*.php
	!index.php
	говорят, что необходимо игнорировать все файлы php, но не игнорировать index.php
 - Можно игнорить всю папку просто поставив вконце слэш
	Например, some_dir/subdir/ - будет игнориться вся папка subdir
 - Комментарии в файле .gitignore начинаются со знака #

Идеи для файлов, которые возможно нужно включить в игнор:
 - скомпилированные исходники
 - пакеты и архивы
 - логи и базы данных
 - файлы сгенерированные операционной системой
 - файлы загруженные юзерами (PDF, video, images ... )
Также имеются статьи и примеры на ресурсах
help.github.com/articles/ignoring-files
github.com/github/gitignore

Может быть случай, когда файл отслеживается и уже был закоммичен, но нет нужды больше в его отслеживании. Даже если его прописать в .gitignore, то он дальше будет отслеживаться, потому что он был ранее закомичен. Чтобы его больше не отслеживать, его нужно прописать в файле игнора, а также удалить его из буфера следующей коммандой
git rm --cached file_name (удалит файл с буфера, но не будет удалять с репозитория и рабочей директории)
После коммита файл больше не будет отслеживаться

Иногда есть необходимость отслеживать пустые директории. Но так как Гит является системой контроля версий файлов, именно файлов, а не директорий, то чтобы начать отслеживать пустую папку люди часто используют следующий трюк: они просто создают пустой файл, по негласному соглашению это файли .gitignore или .gitkeep (это чаще). Как только в папке появляется хоть один файл, Гит начинает ее отслеживать.

----------------------------------------------------------------------------------------------------------------
9. Переход по дереву коммитов

Для перехода по дереву коммитов служит хэш-указатель. В документации он обозначен как tree-ish. Задать tree-ish можно следующими способами:
 - Указать полный SHA коммита (в этом нет крайней необходимоти, так как эти хэши достаточно уникальны)
 - Указать часть SHA (для малого проекта - можно всего 4 символа, для среднего - 8-10, для большого, как проект Линукс, нужно около 12-15)
 - Использовать указатель HEAD (текущий последний коммит)
 - Ветка (бранч) - при этом будет ссылка на верхушку бранча
 - Обращение к предку коммита. Есть правила указания:
	**HEAD^, acasdf23^, master^ (обращение к предку коммита, на кого указывает указатель. Знак ^ указывает "на один уровень вверх")
	**HEAD^^, acasdf23^^, master^^ (обращение к предку коммита, на кого указывает указатель, только уже на 2 уровня выше)
	**HEAD~3, acasdf23~3, master~3 (Если нужно сослать на много уровней вверх, то можно использовать знак ~ и после ее количество уровней вверх)

git ls-tree tree-ish (просмотреть дерево файлов по заданному коммиту)
Некоторые примеры:
git ls-tree HEAD (выдаст состояние файлов текущего коммита, на что указывает HEAD)
git ls-tree master (название ветки указывает на верхушку, тоесть на HEAD, поэтому, результат будет тот же что и выше)
git ls-tree HEAD^ dir_name/ (выдаст состояние файлов текущего коммита, а именно в папке dir_name)
В списке выдачи каждому файлу или папке соответствует свой SHA, поэтому, для выдачи состояния файлов можно указывать не только хэш коммита, но и хэш директории, и Гит выдаст ее состояние в том коммите, откуда взят этот хэш (это работает потому, что хэши уникальны, и совпадение случается раз на миллиард)
git ls-tree SHA_of_dir_in_some_commit (Выдача файлов по хэшу директории)

Полезные опции git log для эффективного поиска нужного коммита
git log --oneline (выдача списка коммитов в одну строчку, это очень компактно)
git log -n (выдача только n записей, где n - число записей)
git log --since="2015-06-20" (Выдача коммитов от 2015-06-20)
git log --after="2015-06-20" (Выдача коммитов от 2015-06-20)
git log --until="2015-06-20" (Выдача коммитов до 2015-06-20)
git log --before="2015-06-20" (Выдача коммитов до 2015-06-20)
git log --since="2 weeks ago" --until="3 days ago" (Выдача коммитов от 2 недель назад до 3 дней назад)
git log --author="Kevin" (Выдача коммитов от автора Kevin)
git log --grep="Obj" (Логи по регулярному выражению с выражением Obj)
git log SHA1..SHA2 --oneline (Выдача коммитов в одну строку в диапазоне между SHA1 и SHA2)
git log SHA.. index.php (Выдача всех коммитов, где были изменения в файле index.php начиная с коммита SHA (не закрытый диапазон ведет до конца))
git log -p (все изменения во всех файлах в формате git diff)
git log --stat --summary (С некоторыми подробностями по каждому файлу)
git log --format=oneline (тоже все в одну строчку, но SHA полные)
git log --format=short/medium/full/fuller/raw (выдача инфы по количеству подробностей)
git log --graph (с графом ветвлений)
git log --oneline --graph --all --decorate (симпатичная выдача списка)

Посмотреть детальную информацию, что же нового произошло в определенном коммите
git show SHA (Посмотреть детальную информацию, что же нового произошло в определенном коммите/tag/tree...)

Сравнение коммитов
git diff SHA (сравнение всех файлов текущего состояния директории и директории на момент указанного коммита)
git diff SHA file_name (сравнение указанного файла текущего состояния директории и директории на момент указанного коммита)
git diff SHA1..SHA2 [file_name] (сравнение коммитов SHA1 и SHA2 [по указанному файлу])
git diff -w SHA1..HEAD (инфа по изменению файлов между указанными коммитами без учета любых модификаций с пробелами, тобишь, они будут игнорироваться)

----------------------------------------------------------------------------------------------------------------
10. Бранчинг в ГИТ

Бранчи (ветки) используются для следующих целей:
 - Для проработки новых идей не влияя на основную разработку. Новые идею можно потом внести (слиять ветки), или удалить (при этом код не замусорен).
 - можно изолировать потоки разработки - каждый занимается в своей ветке
 - Хоть и присуща одна рабочая директория, при переключении бранчей также меняется и содержание контента.

 HEAD всегда указывает на верхушку выбранного бранча.


----------------------------------------------------------------------------------------------------------------


















