ХУЙ
Изучение гит. 
----------------------------------------------------------------------------------------------------------------
1. Общие сведения.

----------------------------------------------------------------------------------------------------------------
2. Установка и настройка Гит
Скачиваем с офсайта git-scm.com (source code manager)
Для Linux необходима дополнительная доустановка скрипта для включения автозаполнения

Настройки бывают 3-х уровней:
 - System. Вцелом для всего компа (кто бы не использовал Гит). Лежат в /etc/gitconfig (Линукс) или /program files/git/etc/gitconfig (Винда)
	Комманда для быстрого редактирования: git config --system
 - User. Настройки для текущего пользователя системы. Лежат в ~/.gitconfig или $HOME/.gitconfig
	git config --global
 - Project. Особые настройки для конкретного пректа. Лежат в my_project/.git/config
	git config [ничего нету - значит для проекта]
	
Базовые настройки:
git config --global user.name "Alex" (Установить имя на уровне пользователя компьютера (уровень user))
git config --global user.email "rpk7@yandex.ru" (Установить мыло автора)
git config --global core.editor "notepad" (устанавливает редактор для тех случаев, когда открывается редактор)
git config --global color.ui true (установить окрашивание в цвета для вывода)
git config --list (отобразить установленные настройки)
git config user.name (выдаст значение этой записи)

----------------------------------------------------------------------------------------------------------------
3. Начинаем
Инициализация репозитория Гит
git init (Выполнить в каталоге, где нужно начать отслеживать; иными словами, эта папка будет репозиторием)
Тут же создалась папка .git, она всегда на самом верхнем уровне созданного репозитория. Ее лучше не трогать. И там лежит вся вся инфа по проекту.

git add file_name (Добавить файл для отслеживания)
git add . (Точка. Добавить все файлы для отслеживания)
git commit -m "Message" (Сделать коммит (слепок) и обозначить его сообщением Message)
git commit -am "Message" (Добавить все файлы в отслеживание и сделать коммит (слепок) и обозначить его сообщением Message)

git log (Список коммитов)
git log -n N (покажет только N записей)
git log --since=2015-05-26 (Показать все коммиты начиная с даты)
git log --until=2-15-05-26 (показать все коммиты кторые были до числа)
git log --author="name of author" (показывает все коммиты определенного автора)
git log --grep="reg_expr" (Ищет коммиты по регулярному выражению в описании)

----------------------------------------------------------------------------------------------------------------
4. Концепция и архетиктура Гит
Архитектура трех деревьев.
При выполнении комманды git add файлы попадают из рабочей дтиректории в буфер, а при выполнении git commit файлы попадают из буфера в репозиторий.
Таким образом достигается гибкость, что позволяет сохранять то что нужно, например, мы сделали много изменений, но для текущего коммита нам не нужны
все файлы. Так, имею промежуточное звено (буфер), мы можем добиваться необходимых результатов.

Структура:
Repository
  |
Staging index (Buffer)
  |
Working directory

В каждом коммите имеется свой хэш SHA-1 (40 символов) со всего слепка (не с файла). И каждый следующий ссылается на предыдущий. Так возможна 
целостность и гит может собирать корректные версии файлов на основании всех предыдущих изменений. Так, это делает невозможным поменять файлы из 
промежуточного коммита, так как это собьет хэши последующий коммитов. 

Существует указатель HEAD, который всегда указывает на верхушку текущего репозитория (последний коммит). Указывает на родителя следующего коммита.
мы можем перемещаться по дереву коммитов, меняя HEAD. 

----------------------------------------------------------------------------------------------------------------
5. Внесение изменений в файлы

Добавление файлов (новых и измененных)
git status (показывает новые, измененные, удаленные, переименованные файлы и папки)
git add file_name (Добавить файл для отслеживания, тоесть, помещение его в буффер, а именно оттуда и идут в коммит)
git reset HEAD file_name (убрать файл из буффера, тоесть вернуть к первоначальному состоянию коммита)

Сравнение файлов
git diff (сверяет файлы из репозитория и рабочей директорией)
git diff file_name (сверяет указанный файл из репозитория и рабочей директорией)
git diff --staged (сравнивает файлы между репозиторием и буфером)

Удаление файлов
Для начала эти файлы должны быть закомичены, иначе нету смысла их удалять\не удалять
Два пути: 
 - Удалить файл из рабочей директории.  (так, при git status он будет помечен как удаленный)
   Потом выполнить git rm file_name (удаляет файл из отслеживаемых).
 - Сразу воспользоваться коммандой
   git rm file_name (удалит файл с рабочей директории и добавит его в буффер на удаление). Так лучше, быстрее и проще. Гит сам за нас все делает.
   
Переименовывание файлов
Тут тоже два способа:
 - Переименовываем файл из рабочей директории. Он новое имя определяет как новый, а старый - как удаленный.
   Новый нужно добавить при помощи git add file_name
   Старый нужно удалить при помощи git rm file_name
   Если посмотреть git status, то при совпадении их содержания (до 50%) он может догадаться что это наш старый файл. И помечает его как переименованный.
 - Второй способ. Тут мы сразу пишем 
   git mv first_name new_name (Переименовывает файлы сам в рабочей директории и добавляет изменения в буффер). Таким образом, мы избавились от ненужных шагов, и этот способ является самым лучшим и быстрым. Гит всё сам делает за нас.

Перемещение файлов
Тоже самое, что и переименовывание. Это синонимы.
git mv git.txt new_dir/test.txt
Гит пометит его как переименованный.

----------------------------------------------------------------------------------------------------------------
6. Использование Гит с реальным проектом

По сути инфа с предыдущих глав. Просто это все показывается на примерах, и детально разжовывается.

----------------------------------------------------------------------------------------------------------------
7. Отмена изменений

Восстановление файлов рабочей директории из репозитория
git checkout file_name (Восстанавливает указанный файл или ветку (ветка в приоритете) с репозитория)
git checkout -- file_name (Восстанавливает указанный файл, два дефиса указываютявно на то, чтоюы оставатьсяв текущей ветке и восстанавливать файл)
git checkout SHA_first_digits -- filename (Восстановить файл с слепка SHA текущей ветки. При кождом чекауте файл добавляется в буфер тут же)

Удаление файлов с буфера
git reset HEAD filename (Удалить из буфера файл. HEAD указывает, что по сути, восстановить состояние буфера как в репозитории на момент HEAD)

Изменение коммитов (последнего) (отменить произвольный невозможно, так как все строится на хэше от предыдущего)
git commit --amend -m "message" (изменить/перезаписать последний коммит)

Зеркальное отображение коммита, тоесть, что было удалено - добавляется, что добавлено - удалено, что измененно - восстанавливается.
При этом создадится новый коммит. По сути, это отмена указанного коммита и автоматическое создание коммита. По идее, это возвращение к состоянию файлов предыдущего коммита, но с созданием нового коммита.
git revert SHA (происходит зеркальное обращение указанного коммита. Появится редактор для редакатирования сообщения и после его закрытия - автокоммит)

Перемотка на любой коммит. Будет подробно идти речь об git reset. До этого о ней было известно как о средстве удаления отслеживаемых файлов из буффера. Но это мощнй инструмент для восстановления файлов.
Есть 3 основные опции :
-- soft (перемещает указатель HEAD на указанный коммит и только. При этом не затрагиваются ни буффер, ни рабочая директория. Самая безопасная. Удобно для дальнейшего выполнения git diff. Если выполнить git status, то будет как измененные файлы ,которые следует закомитить. Это потому, что рабочая директория == буферу, но они не равляются состоянию репозитория)
	git reset --soft SHA
-- mixed (default. Премещает указатель на указанный коммит, не меняет рабочую директорию, но меняет буфер, тоесть, устанавливает его как в указанном коммите. Вот почему по умолчанию эта комманда удаляет файл из буффера, ведь он будет такой же ,как и в коммите)
	git reset --mixed SHA
-- hard (перемещает указатель на указанный комиит, меняет в соответствие ему как буффер, так и рабочую директорию. Самый опасный. При этом удалятся все последуюющие коммиты. Но не сразу, можно будет еще вернуться к последнему коммиту, зная ее SHA)
	git reset --hard SHA
Во всех трёх случаях настоящий последний коммит (а не то куда сейчас стала указывать HEAD) можно вернуть, зная его SHA. Это можно сделать до тех пор, пока не создано новый коммит от перемещенного указателя.

Удаление неотслеживаемых файлов. Когда в проекте имеются побочные файлы (файлы компиляции, временные и т.д.) возникает необходимость их удалить. Ибо нам они только мешают и их отслеживать не требуется. Для удаления неотслеживаемых файлов есть комманда:
git clean (выдаст ошибку, так как обязательно требует параметров)
git clean -n (тестовое удаление, тоесть, выдаст список файлов, которые подлеэат удалению при нетестовой чистке)
git clean -f (Удаляет все неотслеживаемые файлы. Оккуратно!)

----------------------------------------------------------------------------------------------------------------
8. Игнорирование файлов
Для создания правил, какие файлы нужно игнорировать и не отслеживать, для этого можно:
 - создать файл в директории проекта (project_dir/.gitignore) - игнор на уровне проекта
 - Глобальное игнорирование - для этого нужно выполнить ряд действий:
	git config --global core.excludesfiles ~/.gitignore_global (прописать в настройках расположение файла глобального и гнора)
	ну и собственно создать указанный файл и прописать в нем правила игнора
 
В правилах игнора можно указывать по следующих правилах:
 - самые базовые возможности регулярных выражений: * ? [aesad] [0-9]
 - Отрицание с использованием "!"
	Например, такие строки в .gitignore
	*.php
	!index.php
	говорят, что необходимо игнорировать все файлы php, но не игнорировать index.php
 - Можно игнорить всю папку просто поставив вконце слэш
	Например, some_dir/subdir/ - будет игнориться вся папка subdir
 - Комментарии в файле .gitignore начинаются со знака #

Идеи для файлов, которые возможно нужно включить в игнор:
 - скомпилированные исходники
 - пакеты и архивы
 - логи и базы данных
 - файлы сгенерированные операционной системой
 - файлы загруженные юзерами (PDF, video, images ... )
Также имеются статьи и примеры на ресурсах
help.github.com/articles/ignoring-files
github.com/github/gitignore

Может быть случай, когда файл отслеживается и уже был закоммичен, но нет нужды больше в его отслеживании. Даже если его прописать в .gitignore, то он дальше будет отслеживаться, потому что он был ранее закомичен. Чтобы его больше не отслеживать, его нужно прописать в файле игнора, а также удалить его из буфера следующей коммандой
git rm --cached file_name (удалит файл с буфера, но не будет удалять с репозитория и рабочей директории)
После коммита файл больше не будет отслеживаться

Иногда есть необходимость отслеживать пустые директории. Но так как Гит является системой контроля версий файлов, именно файлов, а не директорий, то чтобы начать отслеживать пустую папку люди часто используют следующий трюк: они просто создают пустой файл, по негласному соглашению это файли .gitignore или .gitkeep (это чаще). Как только в папке появляется хоть один файл, Гит начинает ее отслеживать.

----------------------------------------------------------------------------------------------------------------
9. Переход по дереву коммитов

Для перехода по дереву коммитов служит хэш-указатель. В документации он обозначен как tree-ish. Задать tree-ish можно следующими способами:
 - Указать полный SHA коммита (в этом нет крайней необходимоти, так как эти хэши достаточно уникальны)
 - Указать часть SHA (для малого проекта - можно всего 4 символа, для среднего - 8-10, для большого, как проект Линукс, нужно около 12-15)
 - Использовать указатель HEAD (текущий последний коммит)
 - Ветка (бранч) - при этом будет ссылка на верхушку бранча
 - Обращение к предку коммита. Есть правила указания:
	**HEAD^, acasdf23^, master^ (обращение к предку коммита, на кого указывает указатель. Знак ^ указывает "на один уровень вверх")
	**HEAD^^, acasdf23^^, master^^ (обращение к предку коммита, на кого указывает указатель, только уже на 2 уровня выше)
	**HEAD~3, acasdf23~3, master~3 (Если нужно сослать на много уровней вверх, то можно использовать знак ~ и после ее количество уровней вверх)

git ls-tree tree-ish (просмотреть дерево файлов по заданному коммиту)
Некоторые примеры:
git ls-tree HEAD (выдаст состояние файлов текущего коммита, на что указывает HEAD)
git ls-tree master (название ветки указывает на верхушку, тоесть на HEAD, поэтому, результат будет тот же что и выше)
git ls-tree HEAD^ dir_name/ (выдаст состояние файлов текущего коммита, а именно в папке dir_name)
В списке выдачи каждому файлу или папке соответствует свой SHA, поэтому, для выдачи состояния файлов можно указывать не только хэш коммита, но и хэш директории, и Гит выдаст ее состояние в том коммите, откуда взят этот хэш (это работает потому, что хэши уникальны, и совпадение случается раз на миллиард)
git ls-tree SHA_of_dir_in_some_commit (Выдача файлов по хэшу директории)

Полезные опции git log для эффективного поиска нужного коммита
git log --oneline (выдача списка коммитов в одну строчку, это очень компактно)
git log -n (выдача только n записей, где n - число записей)
git log --since="2015-06-20" (Выдача коммитов от 2015-06-20)
git log --after="2015-06-20" (Выдача коммитов от 2015-06-20)
git log --until="2015-06-20" (Выдача коммитов до 2015-06-20)
git log --before="2015-06-20" (Выдача коммитов до 2015-06-20)
git log --since="2 weeks ago" --until="3 days ago" (Выдача коммитов от 2 недель назад до 3 дней назад)
git log --author="Kevin" (Выдача коммитов от автора Kevin)
git log --grep="Obj" (Логи по регулярному выражению с выражением Obj)
git log SHA1..SHA2 --oneline (Выдача коммитов в одну строку в диапазоне между SHA1 и SHA2)
git log SHA.. index.php (Выдача всех коммитов, где были изменения в файле index.php начиная с коммита SHA (не закрытый диапазон ведет до конца))
git log -p (все изменения во всех файлах в формате git diff)
git log --stat --summary (С некоторыми подробностями по каждому файлу)
git log --format=oneline (тоже все в одну строчку, но SHA полные)
git log --format=short/medium/full/fuller/raw (выдача инфы по количеству подробностей)
git log --graph (с графом ветвлений)
git log --oneline --graph --all --decorate (симпатичная выдача списка)

Посмотреть детальную информацию, что же нового произошло в определенном коммите
git show SHA (Посмотреть детальную информацию, что же нового произошло в определенном коммите/tag/tree...)

Сравнение коммитов
git diff SHA (сравнение всех файлов текущего состояния директории и директории на момент указанного коммита)
git diff SHA file_name (сравнение указанного файла текущего состояния директории и директории на момент указанного коммита)
git diff SHA1..SHA2 [file_name] (сравнение коммитов SHA1 и SHA2 [по указанному файлу])
git diff -w SHA1..HEAD (инфа по изменению файлов между указанными коммитами без учета любых модификаций с пробелами, тобишь, они будут игнорироваться)

----------------------------------------------------------------------------------------------------------------
10. Бранчинг в ГИТ

Бранчи (ветки) используются для следующих целей:
 - Для проработки новых идей не влияя на основную разработку. Новые идею можно потом внести (слиять ветки), или удалить (при этом код не замусорен).
 - можно изолировать потоки разработки - каждый занимается в своей ветке
 - Хоть и присуща одна рабочая директория, при переключении бранчей также меняется и содержание контента.

 HEAD всегда указывает на верхушку выбранного бранча.
git branch (выводит название бранчей и указывает на текущий)
git branch new_name (создать новый бранч. Но HEAD будет указывать все еще на текущий, не на новый)
git checkout branch_name (перекдлючиться на другой бранч)
git checkout -b new_name (создает бранч и автоматом HEAD начинает указывать на нее, тоесть, делает чекаут)

Если при переключении бранчей директория не чиста (есть незакоммиченные изменения), то ГИТ откажется переключаться. Есть 3 варианта:
 - можно избавиться от изменений (сделать чекаут файла)
 - закоммитить изменения
 - спрятать в некую область, что при возвращении назад они будут доступны

Сравнение бранчей
git diff master..new_branch (разница между верхушками бранчей)
git diff --color-words master..new_branch (тоже самаое, но разница будет отображаться в одну строчку)
git diff master..new_branch^ (разница между верхушкой бранча master и предыдущим коммитом бранча new_branch)
git branch --merged (покажет все бранча, которые включены в данный бранч, типа, на ком базируется)

Переименование бранчей
git branch -m old_branch_name new_branch_name (переименовать old_branch_name в new_branch_name)
git branch --move old_branch_name new_branch_name (тоже самое)

Удаление бранчей 
Удаление бранчей невозможно, если в ней находитесь. Нужно сменить бранч, прежде чем его удалять.
git branch -d branch_name (Удалить бранч. Удаление бранчей без коммитов)
git branch --delete branch_name (Тоже самое)
git branch -D branch_name (Удаление бранчей даже с существующими коммитами, и вы не сделали слияние)

Настройка командной строки для отображения текущего бранча
для этого нужно настроить переменную окружения следующим образом:
Linux:
export PS1='$(__git_ps1 "(%s)")'
Для постоянного эффекта, а не для текущего сеансанеобходимо внести изменения в ~/.bash_profile : export PS1='$(__git_ps1 "(%s)")'
Windows:
~/.bash_profile : export PS1='\w$(__git_ps1 "(%s)")'

----------------------------------------------------------------------------------------------------------------
11. Слияние бранчей

Слияние необходимо производить из той ветки, в которую хотим слить. Если мы хотим в ветку master влить ветку branch_name, то необходимо находиться в ветке master.
Слияния необходимо делать с чистой рабочей директорией, иначе гит не даст слияться изза возможной потери данных.
git merge branch_name (обьединить ветку branch_name с текущей веткой)

Есть 2 вида слияний:
1. Быстрое слияние. Когда вливаем бранч в ветку, в которой небыло никаких коммитов после ответвления, то новый бранч вливается "по быстрому" - быстрое слияние - 
просто перемещает коммиты в эту ветку. Просто HEAD переносит на эти коммиты.
2. Реальное слияние. Когда в обеих ветках были коммиты, то слияние создается путем создания нового коммита, в котором совмещены обе ветки.

Примеры:
git merge --ff-only branch (сольется только в том случае, если это случай быстрого слияния, иначе просто прервется)
git merge --no-ff branch (обязательно создаст новый коммито слияния, тоесть, произойдет "реальное слияние")

Конфликты слияний
бывают моменты, когда в обеих ветках изменен одинаков документ и изменены одни и те же строки. В таких случаях Гит говорит о конфликте, так как он не знает, 
кому дать приемущество, чей файл "правильный". Таким образом, при слиянии, гит переведет пользователя в режим слияния, и через git status будет указан 
проблемный файл. Пока пользователь пребывает в режиме слияния, гит не создает никаких коммитов, пока конфликт не будет разрешен. 
Есть 3 способа решения конфликтов:
1. Отмена слияния 
	git merge --abort
2. Использование инструментов решения конфликтов
3. Решение конфликтов в ручном режиме.

Решение в ручном режиме. Гит проблемные строки кода помещает в специальные маркеры (<<<<<<< HEAD [...проблемные строки...] ======= [...проблемные строки...] >>>>>>>).
После того, как все конфликты решены (отредактированы), маркеры нужно убрать, и можно коммитить как обычный коммит. Добавляем файл и коммитим. 

----------------------------------------------------------------------------------------------------------------
12 Сохранение изменений в "копилку"

Бывает удобно не коммитить некоторые изменения, или переключиться между ветками не теряя при этом новых наработок. Для этого придумали четвертую область хранения инфы.
Это не рабочая директория, не буфер, не слепок коммита, а именно копилка. Механизм там похожий, но без SHA. 

git stash save -m "message" (сохранение слепка файлов в копилку. После этого происходит git reset --hard HEAD, после чего буфер и рабочая директория обнуляются до состояния последнего коммита)
git stash list (Вывод слепков в копилке. Список будет выгледеть как "stash@{0}:branch_name:message" - просто номер коммита в копилке. 
	Неудобные имена конечно. Указывается ися ветки, с какой было вложено вкопилку, ибо копилка доступна со всех бранчей.)
git stash show stash@{0} (Вывод информации о слепке копилки)
git stash show -p (Выводит изменения в виде патча, тоесть, как git diff)

git stash apply stash@{0} (Вернуть файлы из копилки в рабочую директорию. При этом файлы в копилке остаются. Если имя слепка не указано, вытащится первый.)
git stash pop stash@{0} (Вернуть файлы из копилки в рабочую директорию. При этом файлы в копилке удаляются. Если имя слепка не указано, вытащится первый.)

git stash drop stash@{0} (Удалить слепок с копилки)
git stash clear (Удалить все слепки с копилки)

----------------------------------------------------------------------------------------------------------------
13. Работа с удаленными репозиториями (Remotes)

Представим ситуацию, когда у нас на нашем компьютере есть Гит репозиторий. Но существуют еще серверные Гит, в которых кроме самого Гит еще есть некоторое ПО для
работы с многими пользователями. Мы можем создать удаленный репозиторий на сервере, и заливать (пушить, от push) туда свои коммиты или же брать от туда новые 
коммиты (опрерации идут на уровне бранчей, тоесть, отправляется и принимается ветка со всем набором коммитов), которые создали другие участники проекта. Таким образом получается мультипользовательская система разработки. 
Допустим, на нашем компьютере есть бранч master. При добавлении удаленного репозитория в свой Гит, мы задаем ему имя. Общепринято называть origin, но это не 
обязательно, мы можем задать любое имя для удаленного репозитория. И когда мы пушим некий бранч на удаленный сервер, то автоматически создается на нашем компьютере
ветка, в нашем случае это origin/master (удаленный_репозиторий/название_бранча). Этот бранч создается для того, чтобы было удобно забирать изменения с сервера.
Например, если мы выполняем команду fetch (забрать с сервера), то изменения сначала попадают в origin/master, а уже по необходимости мы делаем слияния с нашим 
локальным бранчем master. Отсюда и обьясняется логика названий этих удаленных бранчей (origin/master) - говорится, какому источнику пренадлеэит и какая ветка в 
нем отслеживается. origin/master, если нету новых изменений, указывает на верхушку ветки master, для экономии ресурсов и облегчения логики. Это знать не обязательно,
но для понимания я обозначил. А теперь детально.

Удаленным Гит репозиторием для обучения выбрано github.com. Заведя аккаунт, у нас есть ссылка, по которой можно обращаться теперь к удаленному репозиторию.
Мы можем посмотреть, какие удаленные репозитории уже подключены для нашего ГИТ коммандо:
git remote   - показывает подключенные удаленные репозитории/бранчи
git remote -v   - показывает больше инфы (урлы для push и fetch комманд)

Потом мы создаем (добавляем) новый удаленный репозиторий:
git remote add <alias> <url>  - Добавить УР с именем <alias> по адресу <url> (адрес мы берем на github.com). Общепринятое имя origin, но мы можем указать любое. Тут же появились настройки в конфигурациооном файле: cat .git/config
git remote rm <alias> - удалить удаленный репозиторий

Отправка бранчей на удаленный репозиторий (Push)
git push -u origin master   -- данная комманда отправляет на удаленный репозиторий origin бранч master. Опция -u указывает на то, что теперь будет отслеживаться указанный бранч (тоесть, master). Теперь, при push и fetch имя бранча можно не указывать, он будет как по умолчанию master.
Как только первый пуш был отправлен, на УР создался бранч в соответствии тому, который мы отправили туда. У нас на компе создалась ветка .git/refs/remotes/origin/master - сейчас она указывает на HEAD нашей ветки master. Если после fetch мы загрузим новые коммиты, то это будет уже не такая ветка master как у нас, а соответственно и не будет указывать на верхушку нашего бранча master. Это отдельный бранч, но так как он удаленный, то и сохраняется в отдельной папке.
git branch -r  - посмотреть удаленные бранчи (origin/master означает УР origin, и ветка master)
git branch -a  - показывает и локальные бранчи, и удаленные

Клонирование бранчей (clone)
git clone <url> <dir_name>  - клонирование УР на локальный комп. Если не указать имени директории, то по умолчанию будет создана директория как имя репозитория (последний параметр в url). Гит склонирует только одну ветку master, так как сейчас там только одна ветка. Но даже если бы было несколько веток, он бы скопировал одну - ту, которая по умолчанию (remote's HEAD). В Github можно настроить бранч по умолчанию. А можно и явно указать, какую ветку мы хотим забрать при клонировании:
git clone -b <branch_name> <url> <dir_name>  - клонирование УР с указанием ветки, какую мы хотим склонировать.








